# MCP 클라이언트 이해하기

## 개요

MCP 클라이언트는 호스트 애플리케이션에 의해 인스턴스화되어 특정 MCP 서버와 통신합니다.

**호스트 애플리케이션**은 Claude.ai나 IDE처럼 전체 사용자 경험을 관리하고 여러 클라이언트를 조정합니다. 각 **클라이언트**는 하나의 서버와 하나의 직접 통신을 처리합니다.

> **중요한 구분**:
> 
> - **호스트 (Host)**: 사용자가 상호작용하는 애플리케이션
> - **클라이언트 (Client)**: 서버 연결을 가능하게 하는 프로토콜 수준 컴포넌트

---

## 클라이언트의 핵심 기능

서버가 제공하는 컨텍스트를 사용하는 것 외에도, 클라이언트는 서버에 여러 기능을 제공할 수 있습니다. 이러한 클라이언트 기능을 통해 서버 작성자는 더 풍부한 상호작용을 구축할 수 있습니다.

|기능|설명|예시|
|---|---|---|
|**Elicitation (유도)**|서버가 상호작용 중 사용자로부터 특정 정보를 요청할 수 있게 하여 온디맨드 방식으로 정보를 수집하는 구조화된 방법 제공|여행 예약 서버가 예약을 완료하기 위해 비행기 좌석 선호도, 객실 유형 또는 연락처를 요청|
|**Roots (루트)**|클라이언트가 서버가 집중해야 할 디렉토리를 지정하여 조정 메커니즘을 통해 의도된 범위를 전달|여행 예약 서버에 특정 디렉토리에 대한 접근 권한을 부여하여 사용자의 캘린더를 읽을 수 있게 함|
|**Sampling (샘플링)**|서버가 클라이언트를 통해 LLM 완성을 요청할 수 있게 하여 에이전틱 워크플로우 가능. 이 접근 방식은 클라이언트가 사용자 권한과 보안 조치를 완전히 제어|여행 예약 서버가 항공편 목록을 LLM에 보내고 LLM이 사용자에게 가장 적합한 항공편을 선택하도록 요청|

---

## 1. Elicitation (유도)

### 개요

Elicitation은 서버가 상호작용 중 사용자로부터 특정 정보를 요청할 수 있게 하여 더욱 동적이고 반응적인 워크플로우를 만듭니다.

**핵심 개념:**

Elicitation은 필요한 정보를 온디맨드 방식으로 수집하는 구조화된 방법을 제공합니다. 모든 정보를 미리 요구하거나 데이터가 누락되었을 때 실패하는 대신, 서버는 작업을 일시 중지하고 사용자로부터 특정 입력을 요청할 수 있습니다. 이를 통해 서버가 고정된 패턴을 따르는 대신 사용자의 요구에 적응하는 더 유연한 상호작용이 가능합니다.

### Elicitation 흐름

동적 정보 수집을 가능하게 하는 흐름:

1. **서버**: 필요할 때 특정 데이터 요청
2. **사용자**: 적절한 UI를 통해 정보 제공
3. **서버**: 새로 획득한 컨텍스트로 처리 계속

### Elicitation 구성 요소 예시

```json
{
  "method": "elicitation/requestInput",
  "params": {
    "message": "Please confirm your Barcelona vacation booking details:",
    "schema": {
      "type": "object",
      "properties": {
        "confirmBooking": {
          "type": "boolean",
          "description": "Confirm the booking (Flights + Hotel = $3,000)"
        },
        "seatPreference": {
          "type": "string",
          "enum": ["window", "aisle", "no preference"],
          "description": "Preferred seat type for flights"
        },
        "roomType": {
          "type": "string",
          "enum": ["sea view", "city view", "garden view"],
          "description": "Preferred room type at hotel"
        },
        "travelInsurance": {
          "type": "boolean",
          "default": false,
          "description": "Add travel insurance ($150)"
        }
      },
      "required": ["confirmBooking"]
    }
  }
}
```

---

### 예제: 휴가 예약 승인

여행 예약 서버는 최종 예약 확인 프로세스를 통해 elicitation의 힘을 보여줍니다.

**시나리오:**

사용자가 바르셀로나로 가는 이상적인 휴가 패키지를 선택했을 때, 서버는 진행하기 전에 최종 승인과 누락된 세부 정보를 수집해야 합니다.

**Elicitation 요청:**

서버는 다음을 포함하는 구조화된 요청으로 예약 확인을 유도합니다:

- 여행 요약 (6월 15-22일 바르셀로나 항공편, 해변가 호텔, 총 $3,000)
- 추가 선호도 필드 (좌석 선택, 객실 유형, 여행 보험 옵션)

**추가 정보 수집:**

예약이 진행되면서 서버는 예약 완료에 필요한 연락처 정보를 유도합니다:

- 항공편 예약을 위한 여행자 세부 정보
- 호텔에 대한 특별 요청
- 비상 연락처 정보

---

### 사용자 상호작용 모델

Elicitation 상호작용은 명확하고, 상황에 맞으며, 사용자 자율성을 존중하도록 설계되었습니다:

#### 요청 제시

클라이언트는 다음과 같은 명확한 컨텍스트와 함께 elicitation 요청을 표시합니다:

- 어떤 서버가 요청하는지
- 왜 정보가 필요한지
- 정보가 어떻게 사용될지

요청 메시지는 목적을 설명하고 스키마는 구조와 검증을 제공합니다.

#### 응답 옵션

사용자는 다음을 수행할 수 있습니다:

- **정보 제공**: 적절한 UI 컨트롤(텍스트 필드, 드롭다운, 체크박스)을 통해
- **제공 거부**: 선택적 설명과 함께
- **작업 취소**: 전체 작업 취소

클라이언트는 서버에 반환하기 전에 제공된 스키마에 대해 응답을 검증합니다.

#### 개인정보 보호 고려사항

- Elicitation은 **절대** 비밀번호나 API 키를 요청하지 않음
- 클라이언트는 의심스러운 요청에 대해 경고
- 사용자가 데이터를 보내기 전에 검토할 수 있게 함

---

## 2. Roots (루트)

### 개요

Roots는 서버 작업에 대한 파일시스템 경계를 정의하여 클라이언트가 서버가 집중해야 할 디렉토리를 지정할 수 있게 합니다.

**핵심 개념:**

Roots는 클라이언트가 서버에 파일시스템 접근 경계를 전달하는 메커니즘입니다. 서버가 작업할 수 있는 디렉토리를 나타내는 파일 URI로 구성되어 서버가 사용 가능한 파일과 폴더의 범위를 이해하는 데 도움을 줍니다.

> **중요**: Roots는 의도된 경계를 전달하지만 보안 제한을 강제하지는 않습니다. 실제 보안은 파일 권한 및/또는 샌드박싱을 통해 운영 체제 수준에서 강제되어야 합니다.

### Root 구조

```json
{
  "uri": "file:///Users/agent/travel-planning",
  "name": "Travel Planning Workspace"
}
```

**Root의 특징:**

- 독점적으로 파일시스템 경로
- 항상 `file://` URI 스키마 사용
- 프로젝트 경계, 워크스페이스 구성, 접근 가능한 디렉토리를 이해하는 데 도움

**동적 업데이트:**

- Roots 목록은 사용자가 다른 프로젝트나 폴더로 작업할 때 동적으로 업데이트 가능
- 서버는 경계가 변경되면 `roots/list_changed` 알림을 받음

---

### 예제: 여행 계획 워크스페이스

여러 클라이언트 여행을 관리하는 여행사는 파일시스템 접근을 구성하는 데 roots를 활용합니다.

**워크스페이스 구조:**

클라이언트가 여행 계획 서버에 파일시스템 roots를 제공합니다:

```
file:///Users/agent/travel-planning        # 모든 여행 파일을 포함하는 메인 워크스페이스
file:///Users/agent/travel-templates       # 재사용 가능한 여정 템플릿 및 리소스
file:///Users/agent/client-documents       # 클라이언트 여권 및 여행 문서
```

**서버 동작:**

에이전트가 바르셀로나 여정을 생성할 때, 잘 동작하는 서버는 이러한 경계를 존중합니다:

- 템플릿에 접근
- 새 여정 저장
- 지정된 roots 내의 클라이언트 문서 참조

**서버가 파일에 접근하는 방법:**

- Root 디렉토리의 상대 경로 사용
- Root 경계를 존중하는 파일 검색 도구 활용

**동적 업데이트 예시:**

에이전트가 `file:///Users/agent/archive/2023-trips` 같은 아카이브 폴더를 열면, 클라이언트는 `roots/list_changed`를 통해 roots 목록을 업데이트합니다.

**참조 구현:**

Roots를 존중하는 서버의 완전한 구현은 공식 서버 저장소의 [filesystem 서버](https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem)를 참조하세요.

---

### 설계 철학

Roots는 클라이언트와 서버 간의 **조정 메커니즘**으로 작동하며, 보안 경계가 아닙니다.

**사양 요구사항:**

- 서버는 root 경계를 "SHOULD respect" (존중해야 함)
- "MUST enforce" (강제해야 함)가 아님
- 이유: 서버는 클라이언트가 제어할 수 없는 코드를 실행

**Roots가 가장 잘 작동하는 경우:**

- 서버가 신뢰되거나 검증됨
- 사용자가 roots의 권고적 성격을 이해함
- 목표가 악의적인 행동을 막는 것이 아니라 사고를 방지하는 것

**Roots의 장점:**

- **컨텍스트 범위 지정**: 서버에 집중할 위치를 알려줌
- **사고 방지**: 잘 동작하는 서버가 경계 내에 머물도록 도움
- **워크플로우 구성**: 프로젝트 경계 자동 관리

---

### 사용자 상호작용 모델

Roots는 일반적으로 사용자 작업에 따라 호스트 애플리케이션에 의해 자동으로 관리되지만, 일부 애플리케이션은 수동 root 관리를 노출할 수 있습니다.

#### 자동 Root 감지

사용자가 폴더를 열면 클라이언트가 자동으로 이를 roots로 노출합니다.

**예시:**

- 여행 워크스페이스를 열면 클라이언트가 해당 디렉토리를 root로 노출
- 서버가 현재 작업 범위에 어떤 여정과 문서가 있는지 이해하는 데 도움

#### 수동 Root 구성

고급 사용자는 구성을 통해 roots를 지정할 수 있습니다.

**예시:**

- 재사용 가능한 리소스를 위해 `/travel-templates` 추가
- 재무 기록이 있는 디렉토리 제외

---

## 3. Sampling (샘플링)

### 개요

Sampling은 서버가 클라이언트를 통해 언어 모델 완성을 요청할 수 있게 하여 보안과 사용자 제어를 유지하면서 에이전틱 동작을 가능하게 합니다.

**핵심 개념:**

Sampling은 서버가 AI 모델과 직접 통합하거나 비용을 지불하지 않고도 AI 종속 작업을 수행할 수 있게 합니다. 대신, 서버는 이미 AI 모델 접근 권한이 있는 클라이언트에게 이러한 작업을 대신 처리하도록 요청할 수 있습니다.

**이 접근 방식의 장점:**

- 클라이언트가 사용자 권한과 보안 조치를 완전히 제어
- 다른 작업(예: 데이터를 분석하는 도구) 컨텍스트 내에서 샘플링 요청이 발생
- 별도의 모델 호출로 처리되어 명확한 경계 유지
- 컨텍스트 윈도우의 더 효율적인 사용 가능

---

### Sampling 흐름

여러 human-in-the-loop 체크포인트를 통해 보안을 보장하는 흐름:

1. **서버**: AI 완성 요청
2. **클라이언트**: 사용자에게 요청 제시
3. **사용자**: 초기 요청 검토 및 수정 가능
4. **클라이언트**: LLM 호출
5. **사용자**: 생성된 응답 검토 및 수정 가능
6. **서버**: 응답 수신 및 처리

---

### 요청 매개변수 예시

```json
{
  "messages": [
    {
      "role": "user",
      "content": "Analyze these flight options and recommend the best choice:\n" +
                 "[47 flights with prices, times, airlines, and layovers]\n" +
                 "User preferences: morning departure, max 1 layover"
    }
  ],
  "modelPreferences": {
    "hints": [{
      "name": "claude-sonnet-4-20250514"  // 제안된 모델
    }],
    "costPriority": 0.3,        // API 비용에 대한 우려 낮음
    "speedPriority": 0.2,       // 철저한 분석을 위해 대기 가능
    "intelligencePriority": 0.9  // 복잡한 트레이드오프 평가 필요
  },
  "systemPrompt": "You are a travel expert helping users find the best flights based on their preferences",
  "maxTokens": 1500
}
```

---

### 예제: 항공편 분석 도구

샘플링을 사용하여 사용 가능한 항공편을 분석하고 최적의 선택을 추천하는 `findBestFlight` 도구가 있는 여행 예약 서버를 고려해봅시다.

**시나리오:**

사용자가 "다음 달 바르셀로나로 가는 최고의 항공편을 예약해줘"라고 요청하면, 도구는 복잡한 트레이드오프를 평가하기 위해 AI 지원이 필요합니다.

#### 프로세스:

1. **데이터 수집**
    
    - 도구가 항공사 API를 쿼리하여 47개의 항공편 옵션을 수집
2. **AI 분석 요청**
    
    - 클라이언트가 샘플링 요청을 시작
    - 프롬프트: "이 항공편 옵션을 분석하고 최선의 선택을 추천해주세요: [가격, 시간, 항공사, 경유지 포함 47개 항공편] 사용자 선호도: 오전 출발, 최대 1회 경유"
3. **AI 평가**
    
    - AI가 트레이드오프 평가 (예: 더 저렴한 심야 항공편 vs. 편리한 오전 출발편)
4. **결과 제시**
    
    - 도구가 이 분석을 사용하여 상위 3개 추천 항공편 제시

---

### 사용자 상호작용 모델

요구사항은 아니지만, 샘플링은 human-in-the-loop 제어를 허용하도록 설계되었습니다. 사용자는 여러 메커니즘을 통해 감독을 유지할 수 있습니다:

#### 승인 제어

샘플링 요청은 명시적 사용자 동의를 요구할 수 있습니다:

- 클라이언트는 서버가 무엇을 분석하려는지, 왜 분석하는지 표시
- 사용자는 승인, 거부 또는 요청 수정 가능

#### 투명성 기능

클라이언트가 다음을 표시할 수 있습니다:

- 정확한 프롬프트
- 모델 선택
- 토큰 제한

사용자는 AI 응답이 서버로 반환되기 전에 검토할 수 있습니다.

#### 구성 옵션

사용자는 다음을 설정할 수 있습니다:

- 모델 선호도 설정
- 신뢰할 수 있는 작업에 대한 자동 승인 구성
- 모든 작업에 대한 승인 요구
- 민감한 정보 삭제 옵션 (클라이언트가 제공 가능)

#### 보안 고려사항

**데이터 처리:**

- 클라이언트와 서버 모두 샘플링 중 민감한 데이터를 적절하게 처리해야 함
- 클라이언트는 속도 제한을 구현하고 모든 메시지 콘텐츠를 검증해야 함

**Human-in-the-loop 설계:**

- 서버가 시작한 AI 상호작용이 명시적 사용자 동의 없이 보안을 손상시키거나 민감한 데이터에 접근할 수 없도록 보장

---

## 요약

MCP 클라이언트는 세 가지 강력한 기능을 통해 서버가 더 풍부한 상호작용을 구축할 수 있게 합니다:

|기능|목적|제어 주체|핵심 장점|
|---|---|---|---|
|**Elicitation**|사용자로부터 정보 수집|서버 요청, 사용자 승인|동적이고 적응형 워크플로우|
|**Roots**|파일시스템 범위 정의|클라이언트/사용자|작업 경계 조정 및 사고 방지|
|**Sampling**|LLM 완성 요청|클라이언트 제어, 사용자 감독|보안을 유지하면서 AI 기능 활용|

이 세 가지 기능은 함께 작동하여:

- 서버가 모델에 직접 접근하지 않고도 AI 기능을 활용할 수 있게 함
- 사용자가 모든 작업과 데이터 흐름을 제어할 수 있게 함
- 보안과 투명성을 유지하면서 강력한 에이전틱 워크플로우를 가능하게 함

---

## 추가 리소스

- **아키텍처**: [Architecture Overview](https://claude.ai/docs/learn/architecture)
- **서버 개념**: [Server Concepts](https://claude.ai/docs/learn/server-concepts)
- **클라이언트 구축**: [Build an MCP Client](https://claude.ai/docs/develop/build-client)
- **버전 관리**: [Versioning](https://claude.ai/specification/versioning)
- **GitHub**: https://github.com/modelcontextprotocol

---

_이 문서는 Model Context Protocol 공식 문서에서 가져온 내용입니다._